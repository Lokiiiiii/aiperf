# SPDX-FileCopyrightText: Copyright (c) 2025-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
"""Core infrastructure for all code generation tools.

This module provides everything needed to build generators with minimal boilerplate:
- Error classes with rich context
- Console output helpers with consistent formatting
- File utilities with change detection
- A Generator base class and runner that handles CLI, timing, and output
"""

from __future__ import annotations

import argparse
import sys
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from rich.console import Console
from rich.panel import Panel
from rich.traceback import Traceback

# =============================================================================
# Console Setup
# =============================================================================

console = Console()
error_console = Console(stderr=True)

# =============================================================================
# Error Classes
# =============================================================================


class GeneratorError(Exception):
    """Base exception for generator errors with rich context.

    Usage:
        raise GeneratorError("Something went wrong", {"file": path, "hint": "Check X"})
    """

    def __init__(self, message: str, details: dict[str, Any] | None = None):
        self.message = message
        self.details = details or {}
        super().__init__(message)


class YAMLLoadError(GeneratorError):
    """Error loading or parsing YAML files."""


class SchemaGenerationError(GeneratorError):
    """Error generating JSON schemas."""


class EnumGenerationError(GeneratorError):
    """Error generating enum files."""


class OverloadGenerationError(GeneratorError):
    """Error generating type overloads."""


class CLIExtractionError(GeneratorError):
    """Error extracting CLI data."""


class ParseError(GeneratorError):
    """Error parsing source files."""


# =============================================================================
# Shared Constants
# =============================================================================

# Pydantic field constraint symbols for documentation
CONSTRAINT_SYMBOLS = {
    "ge": "≥",
    "le": "≤",
    "gt": ">",
    "lt": "<",
    "min_length": "min:",
    "max_length": "max:",
}

# Copyright header for generated markdown files
SPDX_HEADER_MD = (
    "<!--",
    "SPDX-FileCopyrightText: Copyright (c) 2025-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.",
    "SPDX-License-Identifier: Apache-2.0",
    "-->",
)

# Header for auto-generated Python files
GENERATED_FILE_HEADER = (
    "# SPDX-FileCopyrightText: Copyright (c) 2025-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.",
    "# SPDX-License-Identifier: Apache-2.0",
    "# =============================================================================",
    "# ⚠️  AUTO-GENERATED FILE - DO NOT EDIT  ⚠️",
    "# Generated by: ./tools/{generator}.py",
    "# =============================================================================",
)


def make_generated_header(generator: str) -> tuple[str, ...]:
    """Create a generated file header with the generator name."""
    return tuple(line.format(generator=generator) for line in GENERATED_FILE_HEADER)


# =============================================================================
# Console Output Helpers
# =============================================================================


def print_section(title: str) -> None:
    """Print a section header."""
    console.print(f"\n[bold cyan]━━━ {title} ━━━[/]")


def print_generated(path: Path) -> None:
    """Print generated file message."""
    console.print(f"  [green]✓[/] Generated [cyan]{path}[/]")


def print_updated(path: Path) -> None:
    """Print updated file message."""
    console.print(f"  [green]✓[/] Updated [cyan]{path}[/]")


def print_up_to_date(message: str) -> None:
    """Print up-to-date message."""
    console.print(f"  [dim]✓[/] {message}")


def print_out_of_date(message: str) -> None:
    """Print an out-of-date message."""
    console.print(f"  [red]✗[/] {message}")


def print_warning(message: str) -> None:
    """Print warning message."""
    console.print(f"  [yellow]⚠[/] {message}")


def print_step(message: str, timing_ms: float | None = None) -> None:
    """Print a step with optional timing."""
    if timing_ms is not None:
        console.print(f"  [dim]•[/] {message} [dim]({timing_ms:.0f}ms)[/]")
    else:
        console.print(f"  [dim]•[/] {message}")


def print_error(error: Exception, verbose: bool = False) -> None:
    """Print error with optional traceback."""
    if isinstance(error, GeneratorError):
        content = f"[red]{error.message}[/]"
        if error.details:
            content += "\n\n" + "\n".join(
                f"[dim]{k}:[/] {v}" for k, v in error.details.items()
            )
        console.print(Panel(content, title="[red]Error[/]", border_style="red"))
    else:
        console.print(f"  [red]✗[/] {error}")

    if verbose:
        console.print()
        error_console.print(
            Traceback.from_exception(type(error), error, error.__traceback__)
        )


# =============================================================================
# File Utilities
# =============================================================================


def write_if_changed(path: Path, content: str) -> bool:
    """Write file only if content has changed.

    Creates parent directories if they don't exist.

    Returns:
        True if file was written (content changed or didn't exist),
        False if file already had identical content.
    """
    path.parent.mkdir(parents=True, exist_ok=True)

    if path.exists():
        existing = path.read_text()
        if existing == content:
            return False

    path.write_text(content)
    return True


# =============================================================================
# Text Utilities
# =============================================================================


def normalize_text(text: str) -> str:
    """Normalize text by collapsing whitespace and stripping."""
    return " ".join(text.strip().split())


# =============================================================================
# Generator Infrastructure
# =============================================================================


@dataclass
class GeneratedFile:
    """A file to be generated."""

    path: Path
    content: str


@dataclass
class GeneratorResult:
    """Result of a generator run."""

    files: list[GeneratedFile] = field(default_factory=list)
    summary: str = ""  # e.g., "13 subsystems with 93 environment variables"


class Generator(ABC):
    """Base class for code generators.

    Subclasses implement:
    - name: Display name for the generator
    - description: CLI help text
    - generate(): The core generation logic

    Example:
        class MyGenerator(Generator):
            name = "My Generator"
            description = "Generate something cool"

            def generate(self) -> GeneratorResult:
                content = "..."
                return GeneratorResult(
                    files=[GeneratedFile(Path("output.txt"), content)],
                    summary="1 file",
                )

        if __name__ == "__main__":
            run(MyGenerator)
    """

    name: str = "Generator"
    description: str = "Run the generator"

    def __init__(self, verbose: bool = False):
        self.verbose = verbose

    @abstractmethod
    def generate(self) -> GeneratorResult:
        """Generate files and return result.

        Returns:
            GeneratorResult with files to write and summary info.

        Raises:
            GeneratorError: If generation fails.
        """
        ...


def run(generator_class: type[Generator], args: list[str] | None = None) -> int:
    """Run a generator with full CLI handling.

    Handles:
    - Argument parsing (--check, --verbose)
    - Timing
    - Error display with rich formatting
    - File writing with change detection
    - Summary output

    Args:
        generator_class: The generator class to run.
        args: Command line arguments (defaults to sys.argv[1:]).

    Returns:
        Exit code (0 for success, 1 for failure).
    """
    parser = argparse.ArgumentParser(
        description=generator_class.description,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check if files are up-to-date (exit 1 if not)",
    )
    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Show detailed progress and full tracebacks",
    )
    parsed = parser.parse_args(args)

    total_start = time.perf_counter()
    print_section(generator_class.name)

    # Run generator
    try:
        generator = generator_class(verbose=parsed.verbose)
        result = generator.generate()
    except GeneratorError as e:
        print_error(e, verbose=parsed.verbose)
        return 1
    except Exception as e:
        print_error(e, verbose=True)
        return 1

    # Write files
    files_written = 0
    files_out_of_date = 0

    for gen_file in result.files:
        if parsed.check:
            if gen_file.path.exists():
                existing = gen_file.path.read_text()
                if existing == gen_file.content:
                    print_up_to_date(f"{gen_file.path.name} is up-to-date")
                else:
                    print_out_of_date(f"{gen_file.path} needs updating")
                    files_out_of_date += 1
            else:
                print_out_of_date(f"{gen_file.path} does not exist")
                files_out_of_date += 1
        else:
            if write_if_changed(gen_file.path, gen_file.content):
                print_generated(gen_file.path)
                files_written += 1
            else:
                print_up_to_date(f"{gen_file.path.name} is up-to-date")

    # Summary
    total_elapsed = time.perf_counter() - total_start
    console.print()

    if parsed.check and files_out_of_date:
        console.print(
            f"[bold yellow]{files_out_of_date}[/] file(s) would be updated. "
            f"[dim]({total_elapsed:.2f}s)[/]"
        )
        console.print("Run without [cyan]--check[/] to apply.")
        return 1

    if result.summary:
        if files_written:
            console.print(
                f"[bold green]✓[/] Documented {result.summary}. [dim]({total_elapsed:.2f}s)[/]"
            )
        else:
            console.print(
                f"[bold green]✓[/] All {result.summary} up-to-date. [dim]({total_elapsed:.2f}s)[/]"
            )
    elif files_written:
        console.print(
            f"[bold green]✓[/] Generated [bold]{files_written}[/] file(s). "
            f"[dim]({total_elapsed:.2f}s)[/]"
        )
    else:
        console.print(
            f"[bold green]✓[/] All files are up-to-date. [dim]({total_elapsed:.2f}s)[/]"
        )

    return 0


def main(generator_class: type[Generator]) -> None:
    """Entry point helper - call from if __name__ == '__main__'."""
    sys.exit(run(generator_class))
